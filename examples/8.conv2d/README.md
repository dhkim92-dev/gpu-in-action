
# 컨볼루션

이 예제에서는 2차원 입력 행렬에 컨볼루션을 적용하는 예제를 제공합니다.  
우선 용어의 혼란을 피기기 위해 Filter는 입력 행렬에 적용하는 컨볼루션 필터(OpenCV에서 커널) 라고 하고,  
커널은 OpenCL 또는 CUDA의 디바이스 코드로 통일 합니다.  

컨볼루션 연산은 이미지 처리, 신호 처리, 딥러닝 등 광범위하게 사용되는 연산으로 GPGPU를 통해 최적화 하기 좋은 구조입니다. 

## 문제 정의

입력: 채널 수 C(또는 N)을 가지는 2차원 입력 텐서 A(크기 H × W)입니다. 데이터 타입은 float이며, row-major 방식으로 평탄화되어 저장됩니다.

필터(커널): 크기 K × K의 필터 F로서, 입력 채널 수는 C, 출력 채널 수는 M입니다. stride와 padding은 이 예제에서 stride = 1로 고정하고  

출력 크기는 입력과 동일하게 적용합니다. 

따라서 output에 대한 수식은 다음과 같습니다. 

$$
O_{m}(y,x)=\sum_{c=0}^{C-1}\sum_{k_y,k_x=0}^{K-1} A_{c}\bigl(y\cdot s + k_y - p,\; x\cdot s + k_x - p\bigr)\;F_{m,c}(k_y,k_x)
$$
\
### 기호 설명

- $O_{m}(y,x)$ : 출력 텐서의 출력 채널 $m$에서 위치 $(y,x)$의 값입니다. (출력 채널 인덱스 $m=0,\dots,M-1$)
- $A_{c}(r,c)$ : 입력 텐서의 입력 채널 $c$에서 위치 $(r,c)$의 값입니다. (입력 채널 인덱스 $c=0,\dots,C-1$)
- $F_{m,c}(k_y,k_x)$ : 출력 채널 $m$에 기여하는, 입력 채널 $c$의 필터 성분입니다. 필터 좌표는 $(k_y,k_x)$입니다.
- $y,x$ : 출력 공간의 세로(행), 가로(열) 좌표입니다.
- $k_y,k_x$ : 필터 내부의 세로/가로 좌표입니다.
- $K$ : 필터(커널)의 크기(한 변 길이).
- $H,W$ : 입력 텐서의 높이(행 수)와 너비(열 수).
- $H_{out},W_{out}$ : 출력 텐서의 높이와 너비입니다. (예: $H_{out}=\lfloor( H+2p-K)/s\rfloor+1$)
- $s$ : 스트라이드(stride), $p$ : 패딩(padding)입니다. 경계 바깥 좌표는 패딩 처리(예: zero-padding)로 처리합니다.

목적: 주어진 입력 A와 필터 F에 대해 표준 2D 컨볼루션(각 출력 위치에서 필터와 입력의 성분별 곱을 더한 값)을 수행하여 정확한 출력 O를 얻는 것입니다. 구현 시 다음 요건을 만족해야 합니다:
- 정확성: 구현 결과는 CPU 레퍼런스(직접 구현한 순회 기반 컨볼루션)와 일치해야 하며, 허용 오차(epsilon) 범위 내에 있어야 합니다.
- 안전성: 경계 처리(패딩)를 올바르게 수행하여 메모리 오버런이나 쓰레기 값이 발생하지 않아야 합니다.

제약 및 구현 고려사항:
- 데이터 레이아웃: 입력과 출력은 모두 row-major(flattened)로 저장되며, 인덱스 계산을 명확히 해야 합니다.
- 경계 처리: 일반적으로 zero-padding을 사용하며, 커널에서 이를 적절히 처리해야 합니다.

## 커널 종류

- Conv2D-Naive : 단순 Convlution 구현 
- Conv2D-Tiled : 타일 기반 공유메모리 적용 컨볼루션 최적화

## 구현 예제

| CUDA | OpenCL |
|--------------|----------------------|
| [CUDA 코드](./CUDA/kernel.cu) | [OpenCL 코드](./OpenCL/kernel.cl) |